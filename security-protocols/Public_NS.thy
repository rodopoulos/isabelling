(*
  Title: Public-key Needham Schroeder Review
  Author: Felipe Rodopoulos de Oliveira
*)

theory Public_NS

imports "~~/src/HOL/Auth/Public"

begin

consts ns_public :: "event list set"

inductive_set nspublic :: "event list set" where

  Nil: "[] \<in> nspublic"

  | Fake: "\<lbrakk>evsf \<in> nspublic; X \<in> synth (analz (knows Spy evsf))\<rbrakk>
    \<Longrightarrow> Says Spy B X # evsf \<in> nspublic"

  | NS1: "\<lbrakk>evs1 \<in> nspublic; Nonce Na \<notin> used evs1\<rbrakk> 
    \<Longrightarrow> Says A B (Crypt (pubK B) \<lbrace>Nonce Na, Agent A\<rbrace>) # evs1 \<in> nspublic"

  | NS2: "\<lbrakk>evs2 \<in> nspublic; Nonce Nb \<notin> used evs2;
         Says A' B (Crypt (pubK B) \<lbrace>Nonce Na, Agent A\<rbrace>) \<in> set evs2 \<rbrakk> 
    \<Longrightarrow> Says B A (Crypt (pubK A) \<lbrace>Nonce Na, Nonce Nb, Agent B\<rbrace>) # evs2 \<in> nspublic"

  | NS3: "\<lbrakk>evs3 \<in> nspublic;
           Says A B (Crypt (pubK B) \<lbrace>Nonce Na, Agent A\<rbrace>) \<in> set evs3;
           Says B' A (Crypt (pubK A) \<lbrace>Nonce Na, Nonce Nb, Agent B\<rbrace>) \<in> set evs3\<rbrakk> 
    \<Longrightarrow> Says A B (Crypt (pubK B) (Nonce Nb)) # evs3 \<in> nspublic"

(* Avaiable lemmas proved along Inductive Method theory *)
declare knows_Spy_partsEs [elim]
declare analz_into_parts [dest]
declare Fake_parts_insert_in_Un [dest]

section\<open>POSSIBILITY LEMMA\<close>

(* Prove that the protocol reaches an end *)
lemma Protocol_terminates :
  "\<exists>Nb. \<exists>evs \<in> nspublic. Says A B (Crypt (pubK B) (Nonce Nb)) \<in> set evs"
  apply (intro exI bexI)
  apply (rule_tac [2] nspublic.NS3)
  apply (rule_tac [2] nspublic.NS2)
  apply (rule_tac [2] nspublic.NS1)
  apply (rule_tac [2] nspublic.Nil)
  apply (possibility)
  done


  
section\<open>REGULARITY LEMMAS\<close>  

lemma Spy_only_see_compromised_keys [simp] :
  "evs \<in> nspublic \<Longrightarrow> (Key (priK A) \<in> parts (knows Spy evs)) = (A \<in> bad)"
  apply (erule nspublic.induct) (* apply protocol steps *)
  (* Just simply everything. Agent A private key never appears in any message *)
  apply (simp_all)
  (* We are left with one subgoal. We have the two first premises. 
     Luckily, the third one is presented in Inductive Method theory
  *)
  apply (frule Fake_parts_insert) 
  (* Simplify everything. Proof is done. *)
  apply (auto)
  done
  
lemma Spy_only_see_leaked_keys [simp] :
  "evs \<in> nspublic \<Longrightarrow> (Key (priK A) \<in> analz (knows Spy evs)) = (A \<in> bad)"
  (* This is obvious given that analz H \<subseteq> parts H *)
  apply (auto)
  done


  
section\<open>UNICITY LEMMAS\<close>

(* Nonces Na and Nb can't be the same in a given trace. 
   Otherwise, one of them was generated by the Spy.
*)
lemma No_repeated_nonces [rule_format, simp]:
  "\<lbrakk>Crypt (pubK C) \<lbrace>Na', Nonce Na, Agent D\<rbrace> \<in> parts (knows Spy evs);
    Crypt (pubK B) \<lbrace>Nonce Na, Agent A\<rbrace> \<in> parts (knows Spy evs);
    evs \<in> nspublic\<rbrakk>
  \<Longrightarrow> Nonce Na \<in> analz (knows Spy evs)"
  apply (erule rev_mp)
  apply (erule rev_mp)
  apply (erule nspublic.induct, simp_all)
  apply (blast intro: analz_insertI)+
  done

(* Nonce Na identifies Agents A and B. Thus, if we have two messages with
   the same signature as NS1, their components are the same. *)
lemma Na_uniqueness : 
  "\<lbrakk>Crypt (pubK B) \<lbrace>Nonce Na, Agent A\<rbrace> \<in> parts (knows Spy evs); 
    Crypt (pubK B') \<lbrace>Nonce Na, Agent A'\<rbrace> \<in> parts (knows Spy evs);
    Nonce Na \<notin> analz (knows Spy evs); evs \<in> nspublic\<rbrakk>
  \<Longrightarrow> A = A' \<and> B = B'"
apply (erule rev_mp)  
apply (erule rev_mp)
apply (erule rev_mp)
apply (erule nspublic.induct, simp_all)
apply (auto intro: analz_insertI)
done

(* Nonce Nb identify Agents A and B and, consequently, Nonce Na 
   Therefore, if we have two messages with the same signature as NS2
   their components are the same.
*)
lemma Nb_uniqueness [dest] :
  "\<lbrakk>Crypt (pubK A) \<lbrace>Nonce Na, Nonce Nb, Agent B\<rbrace> \<in> parts (knows Spy evs);
    Crypt (pubK A') \<lbrace>Nonce Na', Nonce Nb, Agent B'\<rbrace> \<in> parts (knows Spy evs);
    Nonce Nb \<notin> analz (knows Spy evs); evs \<in> nspublic\<rbrakk> 
   \<Longrightarrow> A = A' \<and> B = B' \<and> Na = Na'"
apply (erule rev_mp)  
apply (erule rev_mp)
apply (erule rev_mp)
apply (erule nspublic.induct, simp_all)
apply (auto intro: analz_insertI)
done



section\<open>SECRECY LEMMAS\<close>
lemma Na_secrecy :
  "\<lbrakk>Says A B (Crypt (pubK B) \<lbrace>Nonce Na, Agent A\<rbrace>) \<in> set evs; 
    A \<notin> bad; B \<notin> bad; evs \<in> nspublic\<rbrakk>
  \<Longrightarrow> Nonce Na \<notin> analz (knows Spy evs)"
apply (erule rev_mp)
apply (erule nspublic.induct, simp_all, spy_analz)
apply (auto intro: No_repeated_nonces dest: Na_uniqueness)
done

(* If B sends message 2 to A and both agents are uncompromised, then Nonce Nb is secure *)
lemma Nb_secrecy :
  "\<lbrakk>Says B A (Crypt (pubK A) \<lbrace>Nonce Na, Nonce Nb, Agent B\<rbrace>) \<in> set evs;
    A \<notin> bad; B \<notin> bad; evs \<in> nspublic\<rbrakk> 
    \<Longrightarrow> Nonce Nb \<notin> analz (knows Spy evs)"
apply (erule rev_mp)
apply (erule nspublic.induct, simp_all, spy_analz)
apply (auto intro: No_repeated_nonces)
done




section\<open>TRUST LEMMAS\<close>

lemma NS2_format [rule_format] :
  "\<lbrakk>Crypt (pubK A) \<lbrace>Nonce Na, Nonce Nb, Agent B\<rbrace> \<in> parts (knows Spy evs);
    Says A B (Crypt (pubK B) \<lbrace>Nonce Na, Agent A\<rbrace>) \<in> set evs;
    A \<notin> bad; B \<notin> bad; evs \<in> nspublic\<rbrakk>
  \<Longrightarrow> Says B A (Crypt (pubK A) \<lbrace>Nonce Na, Nonce Nb, Agent B\<rbrace>) \<in> set evs"
apply (erule rev_mp, erule rev_mp)
apply (erule nspublic.induct, simp_all)
apply (auto dest: Na_secrecy)
done

(* A trust in B is established when A receives NS2
   containing Nonce Na, sent in the first message
*)
lemma A_trusts_B :
  "\<lbrakk>Says A B (Crypt (pubK B) \<lbrace>Nonce Na, Agent A\<rbrace>) \<in> set evs;
    Says B' A (Crypt (pubK A) \<lbrace>Nonce Na, Nonce Nb, Agent B\<rbrace>) \<in> set evs;
    A \<notin> bad; B \<notin> bad; evs \<in> nspublic\<rbrakk> 
  \<Longrightarrow> Says B A (Crypt (pubK A) \<lbrace>Nonce Na, Agent A\<rbrace>) \<in> set evs"
by (blast intro: NS2_format)

(* B trust in A is established when B receives NS3
   containing Nonce Nb, sent on NS2
*)
lemma B_trusts_A :
  "\<lbrakk>Says B A (Crypt (pubK A) \<lbrace>Nonce Na, Nonce Nb, Agent B\<rbrace>) \<in> set evs; 
    Says A' B (Crypt (pubK B) (Nonce Nb)) \<in> set evs;
    A \<notin> bad; B \<notin> bad; evs \<in> nspublic\<rbrakk> 
  \<Longrightarrow> Says A B (Crypt (pubK B) (Nonce Nb)) \<in> set evs"
apply (erule rev_mp, erule rev_mp)
apply (erule nspublic.induct, simp_all)
apply (auto dest: Nb_secrecy)
done
  
end